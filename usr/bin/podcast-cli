#!/bin/bash

function _print_usage {
    # Display usage
    echo
    echo "Usage: $0 [options]"
    echo
    echo "Options:"
    echo "  -h|--help                           Print usage."
    echo "  -q|--quiet                          Nothing will be print to screen, except errors."
    echo ""
    echo "Show level tags:"
    echo "--show"
    echo "  --new"
    echo "  --edit"
    echo "  --delete"
    echo "  --list"
    echo "  --id                                Local identifier of the podcast/show. Decided by the user."
    echo "  --title                             Name of the podcast/show."
    echo "  --owner                             Email address of the owner."
    echo "  --author                            Text name(s) of the author(s) of this podcast.This need not be the same as the owner value."
    echo "  --explicit                          Indicates whether the podcast is explicit language or adult content. You can also tag individual episodes with this property for finer-grained control. Values set for this tag at the episode level override any value set at the show level."
    echo "  --url                               Fully-qualified URL of the homepage of your podcast"
    echo "  --image                             An image to associate with your podcast/show."
    echo "  --category                          Use them as shown below, not translated to any other language: Arts, Business, Comedy, Education, Games &amp; Hobbies, Government &amp; Organizations, Health, Kids &amp; Family, Music, News &amp; Politics, Religion &amp; Spirituality, Science &amp; Medicine, Society &amp; Culture, Sports &amp; Recreation, TV &amp; Film, Technology."
    echo "  --description                       A plaintext description of the podcast/show."
    echo "  --language                          The two-letter language code of the podcast as defined by ISO 639-1."
    echo ""
    echo "Episode level tags:"
    echo "--episode"
    echo "  --show-id                           Identifier of the show's episode."
    echo "  --new"
    echo "  --edit"
    echo "  --delete"
    echo "  --list"
    echo "  --id                                Local identifier of the episode. It is auto-generated."
    echo "  --title                             Title of the podcast episode."
    echo "  --description                       A plaintext description of the episode."
    echo "  --explicit                          Indicates whether this episode contains explicit language or adult content. If absent, the episode inherits the show-level setting. If present, the value declared here overrides the show-level setting."
    echo "  --publication-datetime              Publication date of the episode. [example: 2022-02-15 16:00]"
    echo "  --url                               Fully-qualified URL of the episode audio file."
}

function _generate_random_alphanumeric_string {
    length="${1}"

    to_return="NULL"

    while [ "${#to_return}" != "${length}" ]
    do
        array=()
        for i in {a..z} {A..Z} {0..9}; do
            array[$RANDOM]=$i
        done
        to_return=$(printf %s ${array[@]::length} $'\n')
    done

    echo "${to_return}"
}

function _escape_characters_sql {
    original="${1}"

    echo "${original//\'/\`}"
}

function _get_language_code {
    name_english=${1}

    to_return=$(sqlite3 "${PATH_LOCAL_STORAGE}/databases/system/languages.db" "SELECT iso_639-1 FROM language WHERE name_english='${name_english}';")

    if [ $? -ne 0 ]
    then
        echo "[ERROR] Query DB failed."
        exit 1
    fi

    echo "${to_return}"
}

function _is_url_valid {
    url=${1}

    regex='^(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]\.[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]$'

    if [[ ${url} =~ ${regex} ]]
    then 
        echo "true"
    else
        echo "false"
    fi
}

function _database_insert {
    database_filename="${1}"
    table_name="${2}"
    #columns ('col1', 'col2')
    columns="${3}"
    #values ('value1', 'value2')
    values="${4}"

    sqlite3 "${database_filename}" "INSERT INTO ${table_name} (${columns}) VALUES (${values});"

    #to be moved into main script
    if [ $? -ne 0 ]
    then
        echo FAIL
    fi
}

function _database_update {
    database_filename="${1}"
    table_name="${2}"
    #SET ContactName='Alfred Schmidt',City='Frankfurt'
    set="${3}"
    #condition id='5'
    condition="${4}"

    sqlite3 "${database_filename}" "UPDATE ${table_name} SET ${set} WHERE ${condition};"

    #to be moved into main script
    if [ $? -ne 0 ]
    then
        echo FAIL
    fi
}

function _database_delete {
    database_filename="${1}"
    table_name="${2}"
    #condition id='5'
    condition="${3}"

    sqlite3 "${database_filename}" "DELETE FROM ${table_name} WHERE ${condition};"

    #to be moved into main script
    if [ $? -ne 0 ]
    then
        echo FAIL
    fi
}

# function _list_available_qualities {
# 	url_parameter=${1}

#     streamlink "${url_parameter}"
# }

# function _download {
# 	url_parameter=${1}
# 	quality_parameter=${2}
# 	filename_output_parameter=${3}
# 	path_download_parameter=${4}
# 	http_no_ssl_verify_parameter=${5}

# 	mkdir -p "${path_download_parameter}"
# 	cd "${path_download_parameter}"

# 	if [ "${http_no_ssl_verify_parameter}" != "true" ];
# 	then
# 		streamlink "${url_parameter}" "${quality_parameter}" -o "${filename_output_parameter}"
# 	else
#         streamlink --http-no-ssl-verify "${url_parameter}" "${quality_parameter}" -o "${filename_output_parameter}"
# 	fi
# }

PATH_LOCAL_STORAGE="/etc/podcast-cli"

# Execute getopt on the arguments passed to this program, identified by the special character $@
PARSED_OPTIONS=$(getopt -n "$0" -o h,q --long "help,quiet,show,episode,new,edit,delete,list,backup,restore,feed,id:,show-id:,title:,owner:,author:,explicit:,url:,image:,category:,description:,language:,publication-datetime:" -- "$@")

#Bad arguments, something has gone wrong with the getopt command.
if [ $? -ne 0 ];
then
    #_print_error "Bad arguments."
    echo "[error] Something has gone wrong with the getopt command."
    exit 1
fi

# A little magic, necessary when using getopt.
eval set -- "${PARSED_OPTIONS}"

# Initialize variables
is_quiet="false"
is_show="false"
is_episode="false"
is_new="false"
is_edit="false"
is_delete="false"
is_list="false"
is_backup="false"
is_restore="false"
is_feed="false"
id="NULL"
show_id="NULL"
title="NULL"
owner="NULL"
author="NULL"
explicit="NULL"
url="NULL"
image="NULL"
category="NULL"
description="NULL"
language="NULL"
publication_datetime="NULL"

# Now goes through all the options with a case and using shift to analyse 1 argument at a time.
#$1 identifies the first argument, and when we use shift we discard the first argument, so $2 becomes $1 and goes again through the case.
while true;
do
    case "${1}" in
        -h|--help)
            _print_usage
            exit 0
            shift;;
        -q|--quiet)
            is_quiet="true"
            shift;;
        --show)
            is_show="true"
            shift;;
        --episode)
            is_episode="true"
            shift;;
        --new)
            is_new="true"
            shift;;
        --edit)
            is_edit="true"
            shift;;
        --delete)
            is_delete="true"
            shift;;
        --list)
            is_list="true"
            shift;;
        --backup)
            is_backup="true"
            shift;;
        --restore)
            is_restore="true"
            shift;;
        --feed)
            is_feed="true"
            shift;;
        --id)
            if [ -n "${2}" ]
            then
                id="${2}"
            fi
            shift 2;;
        --show-id)
            if [ -n "${2}" ]
            then
                show_id="${2}"
            fi
            shift 2;;
        --title)
            if [ -n "${2}" ]
            then
                title="${2}"
            fi
            shift 2;;
        --owner)
            if [ -n "${2}" ]
            then
                owner="${2}"
            fi
            shift 2;;
        --author)
            if [ -n "${2}" ]
            then
                author="${2}"
            fi
            shift 2;;
        --explicit)
            if [ -n "${2}" ]
            then
                explicit="${2}"
            fi
            shift 2;;
        --url)
            if [ -n "${2}" ]
            then
                url="${2}"
            fi
            shift 2;;
        --image)
            if [ -n "${2}" ]
            then
                image="${2}"
            fi
            shift 2;;
        --category)
            if [ -n "${2}" ]
            then
                category="${2}"
            fi
            shift 2;;
        --description)
            if [ -n "${2}" ]
            then
                description="${2}"
            fi
            shift 2;;
        --language)
            if [ -n "${2}" ]
            then
                language="${2}"
            fi
            shift 2;;
        --publication-datetime)
            if [ -n "${2}" ]
            then
                publication_datetime="${2}"
            fi
            shift 2;;
        --)
            shift
            break;;
    esac
done

_escape_characters_sql "L'ascia"
_is_url_valid "https://www.google.co"

#random_alphanumeric_string=$(_generate_random_alphanumeric_string '16')
#echo "[debug] random_alphanumeric_string: ${random_alphanumeric_string}"

# create 'command'
command=""
if [ "${is_show}" == "true" ]; then command+="show"; fi
if [ "${is_episode}" == "true" ]; then command+="episode"; fi
if [ "${is_new}" == "true" ]; then command+=".new"; fi
if [ "${is_edit}" == "true" ]; then command+=".edit"; fi
if [ "${is_delete}" == "true" ]; then command+=".delete"; fi
if [ "${is_list}" == "true" ]; then command+=".list"; fi
if [ "${is_backup}" == "true" ]; then command+=".backup"; fi
if [ "${is_restore}" == "true" ]; then command+=".restore"; fi
if [ "${is_feed}" == "true" ]; then command+=".feed"; fi

echo "command: ${command}"

exit 0;

cd "${PATH_LOCAL_STORAGE}"
cd "./databases"

if [ ! -f "./active/shows.db" ]
then
    # 'shows.db' doesn't exist
    # copy 'shows.db' from empty directory
    cp -n "./empty/shows.db" "./active"

    if [ $? -ne 0 ]
    then
        echo "[ERROR] Command failed [copy-empty-shows-db]"
        exit 1
    fi
fi


case "${command}" in
    "show.new")
        columns=""
        values=""

        # Required parameters
        if [ -z "${id}" ] || [ "${id}" == "NULL" ]
        then
            echo "[ERROR] Required option 'id' is missing or empty."
            _print_usage
            exit 1
        else
            columns+="id"
            values+="'${id}'"
        fi

        if [ -z "${url}" ] || [ "${url}" == "NULL" ]
        then
            echo "[ERROR] Required parameters are missing or empty."
            _print_usage
            exit 1
        else
            if [ "$(is_url_valid "${url}")" == "false" ]
            then
                echo "[ERROR] Url is invalid."
                _print_usage
                exit 1
            else
                columns+=",url"
                values+=",'${url}'"
            fi
        fi

        if [ -z "${title}" ] || [ "${title}" == "NULL" ]
        then
            echo "[ERROR] Required parameters are missing or empty."
            _print_usage
            exit 1
        else
            columns+=",title"
            values+=",'${title}'"
        fi

        if [ -z "${image}" ] || [ "${image}" == "NULL" ]
        then
            echo "[ERROR] Required parameters are missing or empty."
            _print_usage
            exit 1
        else
            if [ "$(is_url_valid "${url}")" == "false" ]
            then
                echo "[ERROR] 'image' url is invalid."
                _print_usage
                exit 1
            else
                columns+=",image"
                values+=",'${image}'"
            fi
        fi

        if [ -z "${description}" ] || [ "${description}" == "NULL" ]
        then
            echo "[ERROR] Required parameters are missing or empty."
            _print_usage
            exit 1
        else
            columns+=",description"
            values+=",'${description}'"
        fi

        if [ -z "${author}" ] || [ "${author}" == "NULL" ]
        then
            echo "[ERROR] Required parameters are missing or empty."
            _print_usage
            exit 1
        else
            columns+=",author"
            values+=",'${author}'"
        fi

        if [ -z "${owner}" ] || [ "${owner}" == "NULL" ]
        then
            echo "[ERROR] Required parameters are missing or empty."
            _print_usage
            exit 1
        else
            columns+=",owner"
            values+=",'${owner}'"
        fi

        # Optional parameters
        # category
        if [ -z "${category}" ] || [ "${category}" == "NULL" ]
        then
            echo "[ERROR] Required option 'category' is missing or empty."
            _print_usage
            exit 1
        else
            columns+=",category"
            values+=",'${category}'"
        fi

        # explicit
        if [ -z "${explicit}" ] || [ "${explicit}" == "NULL" ]
        then
            explicit="false"
            columns+=",explicit"
            values+=",'${explicit}'"
        else
            if [ "${explicit}" == "true" ] || [ "${explicit}" == "false" ] 
            then
                columns+=",explicit"
                values+=",'${explicit}'"
            else
                echo "[ERROR] Unknown value for explicit option."
                _print_usage
                exit 1
            fi
        fi

        # language
        if [ -z "${language}" ] || [ "${language}" == "NULL" ]
        then
            echo "[ERROR] Required parameters are missing or empty."
            _print_usage
            exit 1
        else
            language_code=$(_get_language_code "${language}")
            if [ -z "${language_code}" ] || [ "${language_code}" == "NULL" ]
            then
                echo "[ERROR] Language not found."
                _print_usage
                exit 1
            else
                columns+=",language"
                values+=",'${language_code}'"
            fi
        fi

        
        
        #./databases/active
        cd "./active"
        _database_insert "shows.db" "show" "id,title,owner,author," "'${id}','${title}','${owner}','${author}'"

        if [ $? -ne 0 ]
        then
            echo "[ERROR] Command failed."
            exit 1
        fi
        ;;
    "show.edit")
        is_show="true"
        ;;
    "show.delete")
        is_show="true"
        ;;
    "show.backup")
        is_show="true"
        ;;
    "show.restore")
        is_show="true"
        ;;
    "show.feed")
        is_show="true"
        ;;
    "episode.new")
        is_episode="true"
        ;;
    "episode.edit")
        is_new="true"
        ;;
    "episode.delete")
        is_edit="true"
        ;;
    *)
        echo "ERROR: unknown command."
        _print_usage
        exit 1
        ;;
esac


exit 0;



exit 0;

cd "${PATH_LOCAL_STORAGE}"

cd "./databases"
if [ ! -f "./active/shows.db" ]
then
    # 'shows.db' doesn't exist
    # copy 'shows.db' from empty directory
    cp -n "./empty/shows.db" "./active"
fi

# # index arrays
# INDEX_URL=0
# INDEX_QUALITY=1
# INDEX_FILENAME_OUTPUT=2

# # save lines in array
# i=0
# while IFS= read -r line || [ -n "${line}" ]; 
# do
#     line_parsed=$(printf '%s\n' "$line" | tr -d '\r')

#     IFS='|' read -ra splitted_line_array <<< "$line_parsed"

#     if [ "${is_download}" == "true" ] && [ "${is_list_available_qualities}" == "true" ];
#     then
#         echo "[error] Choose one thing to do."
#         _print_usage
#         exit 1
#     else
#         echo "---------------------------------------------------------------"
#         echo "[debug] url: ${splitted_line_array[INDEX_URL]}"
#         echo "[debug] quality: ${splitted_line_array[INDEX_QUALITY]}"
#         echo "[debug] filename_output: ${splitted_line_array[INDEX_FILENAME_OUTPUT]}"
        
#         if [ "${is_download}" == "true" ];
#         then
#             echo "[debug] action to perform: download"
#             if [ "${path_download_input}" != "NULL" ] && [ "${path_download_input}" != "" ];
#             then
#                 _download "${splitted_line_array[INDEX_URL]}" "${splitted_line_array[INDEX_QUALITY]}" "${splitted_line_array[INDEX_FILENAME_OUTPUT]}" "${path_download_input}"
#             else
#                 _download "${splitted_line_array[INDEX_URL]}" "${splitted_line_array[INDEX_QUALITY]}" "${splitted_line_array[INDEX_FILENAME_OUTPUT]}" "${PATH_DOWNLOAD_DEFAULT}"
#             fi
#         else
#             echo "[debug] action to perform: list available qualities"

#             _list_available_qualities "${splitted_line_array[INDEX_URL]}"
#         fi
#         echo "---------------------------------------------------------------"
#     fi
# done <${FILENAME_LIST}

echo "[info] Execution completed."